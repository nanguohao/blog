## 【译文】Mockito vs EasyMock vs JMockit[(原文地址,请勿转载)](https://www.baeldung.com/mockito-vs-easymock-vs-jmockit)
### 1.介绍
#### 1.1.概要
 &emsp;&emsp;本文将介绍mocking的概念，为什么使用mocking以及展示使用几个常用的java mocking框架对同一个测试案例进行mock的例子。
 &emsp;&emsp;我们将首先给出形式化/半形式化的定义，然后展示Mockito，EasyMock和JMockit的例子，最后进行总结。
 &emsp;&emsp;如果你已经具备mocking的基础概念，可以直接跳到第二部分。

#### 1.2.为什么使用mock
 &emsp;&emsp;我们假设你已经以测试为驱动进行开发（TDD，ATDD或者BDD）。或者你需要测试的那个类依赖别的类来实现功能。
 &emsp;&emsp;在一个类的单元测试中，我们仅仅想测试它的功能，并不想测试它的依赖（我们信任其依赖类的实现或者我们会单独测试依赖类）。
 &emsp;&emsp;为了达到上述目的，我们需要给被测类提供一个我们可以控制的依赖类。通过mock我们可以控制方法返回特定的值，抛出异常或者是指定方法的消耗时间。

#### 1.3.mock的概念与定义
 &emsp;&emsp;Martin Flower在一篇[论文](https://martinfowler.com/articles/mocksArentStubs.html)中总结了关于mock的四个基本定义：
- **Dummy objects** 被作为传递参数但是从来未被使用。通常用来填充参数列表。
- **Fake objects** 具有功能实现，但是实现往往采用了某些便捷方式，因此不适合在生产环境中使用（内存数据库是个很好的例子）
- **Stubs** 在测试中对于调用提供固定的结果，通常不会在测试中给出内置的编码之外的任何回应。stubs可能记录调用的信息，例如email gateway stub能记录发出的消息，也可能只记录发出的邮件数目。
- **Mocks** 预先按照调用者期望的返回行为设置的对象。

#### 1.4.是否使用mock
  &emsp;&emsp;**不是所有的东西都需要mock。** 有时，最好进行集成测试，如果使用mock收效微乎其微。
Not everything must be mocked. Sometimes it’s better to do an integration test as mocking that method/feature would be just working for little actual benefit. In our test case (that will be shown in the next point) that would be testing the LoginDao.

The LoginDao would use some third party library for DB access, and mocking it would only consist on assuring that parameters had been prepared for the call, but we still would need to test that the call returns the data we wanted.

For that reason, it won’t be included in this example (although we could write both the unit test with mock calls for the third party library calls AND an integration test with DBUnit for testing the actual performance of the third party library).

### 2.测试案例
 &emsp;&emsp;本节提出一个使用mock的典型案例，这为我们后续的mock库比较建立一个通用的场景。
#### 2.1.提出案例
 &emsp;&emsp;测试案例是一个具有分层架构的应用的登陆过程。登陆请求将被controller处理，继而调用service，然后通过DAO，DAO会在DB中查找用户凭证。我们不会太深入各层的实现，而主要关注各层组件间的交互。我们具有一个LoginController，LoginService和LoginDao。调用关系如下：
 
