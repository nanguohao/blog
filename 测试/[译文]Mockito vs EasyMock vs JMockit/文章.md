## 【译文】Mockito vs EasyMock vs JMockit[(原文地址,请勿转载)](https://www.baeldung.com/mockito-vs-easymock-vs-jmockit)
### 1.介绍
#### 1.1.概要
##### &emsp;&emsp;本文将介绍mocking的概念，为什么使用mocking以及展示使用几个常用的java mocking框架对同一个测试案例进行mock的例子。
##### &emsp;&emsp;我们将首先给出形式化/半形式化的定义，然后展示Mockito，EasyMock和JMockit的例子，最后进行总结。
##### &emsp;&emsp;如果你已经具备mocking的基础概念，可以直接跳到第二部分。

#### 1.2.为什么使用mock
##### &emsp;&emsp;我们假设你已经以测试为驱动进行开发（TDD，ATDD或者BDD）。或者你需要测试的那个类依赖别的类来实现功能。
##### &emsp;&emsp;在一个类的单元测试中，我们仅仅想测试它的功能，并不想测试它的依赖（我们信任其依赖类的实现或者我们会单独测试依赖类）。
##### &emsp;&emsp;为了达到上述目的，我们需要给被测类提供一个我们可以控制的依赖类。通过mock我们可以控制方法返回特定的值，抛出异常或者是指定方法的消耗时间。

#### 1.3.mock的概念与定义
##### &emsp;&emsp;Martin Flower在一篇[论文](https://martinfowler.com/articles/mocksArentStubs.html)中总结了关于mock的四个基本定义：
- **Dummy objects** 被作为传递参数但是从来未被使用。通常用来填充参数列表。
- **Fake objects** 具有功能实现，但是实现往往采用了某些便捷方式，因此不适合在生产环境中使用（内存数据库是个很好的例子）
- **Stubs** 在测试中对于调用提供固定的结果，通常不会在测试中给出内置的编码之外的任何回应。stubs可能记录调用的信息，例如email gateway stub能记录发出的消息，也可能只记录发出的邮件数目。
- **Mocks** 预先按照调用者期望的返回行为设置的对象。


